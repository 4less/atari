
{% extends "base.html" %}

{% block scripts %}
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
{% endblock %}


{% block content %}
<script>
	var height = 600;
	var width = 600;
	var padding = 100;

	var drawScatterPlot = function(dataset, svgScatter){
		var xScale = d3.scale.linear();
		xScale.domain([0, 1000]); // data
		xScale.range([padding, width - padding]); // pixels
		
		var yScale = d3.scale.linear();
		yScale.domain([0, 1000]); // data
	 	yScale.range([height-padding, padding]); // pixels

	 	// creating axes
	 	var xAxis = d3.svg.axis()
						   .scale(xScale)
						   .orient("bottom");
		var yAxis = d3.svg.axis()
						   .scale(yScale)
						   .orient("left");

		circles = svgScatter.selectAll("circle")
					    	.data(dataset[0])
					    	.enter()
					    	.append("circle")	
					    	.attr("cx", function(d) {return xScale(d[0])})
					    	.attr("cy", function(d) {return yScale(d[1])})
					    	.attr("r", function(d) {return 10})
					    	.attr("fill", "green");

		labels = svgScatter.selectAll("text")
						   .data(dataset[0])
						   .enter()
						   .append("text")	
						   .attr("x", function(d) {return xScale(d[0]) + 12})
						   .attr("y", function(d) {return yScale(d[1]) + 3})
						   .attr("font-size", "12px")
						   .text(function(d) {return Math.round(d[0]) + ',' + Math.round(d[1])});	

		// on click in d3. Its a function and therefore you can do anything in its body
		// .transition generates an animation, .duration specifies how much time the
		// animation is going to take
		var timesClicked = 0;
		circles.on('click', function(){
					timesClicked += 1;
					circles.data(dataset[timesClicked%5])
						   .transition()
						   .duration(1000)
						   .attr("cx", function(d) {return xScale(d[0])})
						   .attr("cy", function(d) {return yScale(d[1])});
					
					labels.data(dataset[timesClicked%5])
						  .transition()
						  .duration(1000)
						  .attr("x", function(d) {return xScale(d[0])+ 12})
						  .attr("y", function(d) {return yScale(d[1]) + 3})
						  .attr("font-size", "12px")
						  .text(function(d) {return Math.round(d[0]) + ',' + Math.round(d[1])});	

			});


		// this refers to the svg element that was interacted with directly
		// circles variable holds a list of circles, this refers to an element of the
		// list
		circles.on("mouseover", function(){
			d3.select(this)
			  .attr("fill", "orange");
		});

		circles.on("mouseout", function(){
			d3.select(this)
			  .attr("fill", "red");

		});

		//adding axes to the svg element, remember about () if you need to perform
		//computation, since this is a string (in "") and the computation has to 
		// be performed before creating a string.
		// In svg the sequence of adding elements determines what is visible.
		// If we want axes to be drew on the bubbles, need to be added after them
	    svgScatter.append("g")
	    	.attr("transform", "translate(0, " + (height-padding) + ")")
	    	.attr("class", "axis")
			.call(xAxis);

		svgScatter.append("g")
			.attr("transform", "translate(" + padding  + ", 0)")
			.attr("class", "axis")
			.call(yAxis);
	};

	// generating data
	var dataset = {{ data | safe }};

	// creating svg element
	var svg = d3.select("#content").append("svg")
	            .attr("width", width)
	            .attr("height", height);
	drawScatterPlot(dataset, svg);

</script>
{% endblock %}
